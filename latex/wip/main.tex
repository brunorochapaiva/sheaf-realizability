\documentclass[11pt]{article}

\newif\ifnotes
\notestrue % comment out to hide notes

\DeclareUnicodeCharacter{03A3}{\(\Sigma\)}
\DeclareUnicodeCharacter{03A0}{\(\Pi\)}
\DeclareFontFamily{U}{min}{}
\DeclareFontShape{U}{min}{m}{n}{<-> udmj30}{}
\newcommand\yo{\!\text{\usefont{U}{min}{m}{n}\symbol{'207}}\!}

\input{packages-to-include}

% Need this nonsense so that cleveref uses the correct names for references
\let\oldtheorem\newtheorem
\RenewDocumentCommand{\newtheorem}{s m o m O{}}{%
\IfBooleanTF{#1}%
{\oldtheorem{#2}{#4}}%
{\IfNoValueTF{#3}{\oldtheorem{#2}{#4}[#5]}%
{\newaliascnt{#2}{#3}%
\oldtheorem{#2}[#2]{#4}%
\aliascntresetthe{#2}}}}

\newtheorem{thrm}{Theorem}[subsection]
\newtheorem{lemm}[thrm]{Lemma}
\newtheorem{prop}[thrm]{Proposition}
\newtheorem{defn}[thrm]{Definition}
\newtheorem{remk}[thrm]{Remark}
\newtheorem{exam}[thrm]{Example}
\newtheorem{cons}[thrm]{Construction}
\newtheorem{coro}[thrm]{Corollary}
\newtheorem{nota}[thrm]{Notation}

\input{macros}

%--------------------------------------------------------------------------------
% Document proper
\begin{document}

\title{Realizability with Sheaves}
\author{Bruno da Rocha Paiva}
\maketitle

We begin a treatment of realizability internal to categories of sheaves.

\section{Preliminaries on working internally}

For the whole of this section we define and prove things in the internal
language of an elementary topos \(\E\).

\subsection{Lawvere-Tierney topologies}%
\label{sub:lawvere-tierney-internal}

Lawvere-Tierney topologies are an internal representation for subtoposes
of \(\E\).

\begin{defn}\label{defn:lawvere-tierney}
  A \definiendum{Lawvere-Tierney topology} on is a function
  \(\IBoxSym : \Omega \to \Omega\) such that for all propositions \(P,Q\), both
  \(\IImplies{P}{\IBox{P}}\) and
  \(\IImplies{(\IImplies{P}{\IBox{Q}})}{\IImplies{\IBox{P}}{\IBox{Q}}}\) hold.
\end{defn}

\subsection{Sheaves}%
\label{sub:sheaves-internal}

Once we have fixed a Lawvere-Tierney topology \(\IBoxSym : \IProp \to \IProp\),
we have the following internal definition of sheaves:

\begin{defn}
  A type \(A\) is a \definiendum{sheaf} if we have a function
  %
  \[
    \IGlue{A} : (P : \IProp) \to \IHolds{\IBox{P}} \to (\IHolds{P} \to A) \to A
  \]
  %
  such that for all propositions \(P\) and proofs \(q : \IHolds{\IBox{P}}\),
  we have the following equivalence of types:
  %
  \[
    \IGlue{A}\,P\,q : (\IHolds{P} \to A) \cong A : \text{const}
  \]
\end{defn}

We note that as we ask that the \(\text{const}\) function be an equivalence,
being a sheaf is a property of a type \(A\) and not extra structure.
%
In the case that the type \(A\) is a set, which is always true in our setting,
then it is equivalent to prove only that the composite
\((\IGlue{A}\,P\,q) \circ \text{const}\) sends each \(a : A\) to itself.

Any map \(f : A \to B\) induces a map
\((f\circ-) : (\IHolds{P} \to A) \to (\IHolds{P} \to B)\) by post-composition.
%
In the case that \(A\) and \(B\) are both sheaves, then the gluing function
will give a natural transformation.

\begin{prop}
  Given sheaves \(A\) and \(B\), a function \(f : A \to B\), a proposition \(P\)
  and \(q : \IHolds{P}\), then the following naturality square commutes:
  %
  \[\begin{tikzcd}
      (\IHolds{P} \to A) \arrow[rr , "\IGlue{A}\,P\,q"] \arrow[d, "(f\circ-)"'] && A \arrow[d, "f"]\\
      (\IHolds{P} \to B) \arrow[rr , "\IGlue{B}\,P\,q"] && B
    \end{tikzcd}\]
\end{prop}
\begin{proof}
  Fix \(f : A \to B\), a proposition \(P\), \(q : \IHolds{P}\) and
  \(\phi : \IHolds{P} \to A\) so we are left to show that
  \(f(\IGlue{A}\,P\,q\,\phi) = \IGlue{B}\,P\,q\,(f \circ \phi)\).
  %
  Well, we have the following sequence of equalities:
  %
  \begin{align*}
    &f(\IGlue{A}\,P\,q\,\phi)\\
    &\quad=
      f(\IGlue{A}\,P\,q\,(\ILam{p':\IHolds{P}}\phi\,p'))
      \\
    &\quad=
      \IGlue{B}\,P\,q\,(\ILam{p:\IHolds{P}}{f(\IGlue{A}\,P\,q\,(\ILam{p':\IHolds{P}}\phi\,p'))})
      \\
    &\quad=
      \IGlue{B}\,P\,q\,(\ILam{p:\IHolds{P}}{f(\IGlue{A}\,P\,q\,(\ILam{p':\IHolds{P}}\phi\,p))})
      \\
    &\quad=
      \IGlue{B}\,P\,q\,(\ILam{p:\IHolds{P}}{f(\phi\,p)})
      \\
    &\quad=\IGlue{B}\,P\,q\,(f \circ \phi)
  \end{align*}
  %
  where the first and last equalities are \(\eta\)-expansions,
  the second and second to last equalities hold since gluing a constant
  family gives the original element, and the third equality holds
  since \(p\) and \(p'\) are both elements of the same proposition, so they
  are necessarily equal.
\end{proof}

Sheaves have nice closure properties with regards to the constructors of type
theory.

\begin{prop}
  Given a type family \(F : A \to \IUni\) such that for \(Fa\) is a sheaf for
  all \(a : A\), then the dependent product \((a : A) \to Fa\) is also a
  sheaf.
\end{prop}

\begin{prop}%
\label{prop:sums-preserve-sheaf}
  Given a type family \(F : A \to \IUni\) such that \(A\) is a sheaf and \(Fa\)
  is a sheaf for all \(a : A\), then the dependent sum \((a : A) \times Fa\)
  is also a sheaf.
\end{prop}

\begin{prop}
  Given a sheaf \(A\) and elements \(a\ b : A\), the identity type \(a = b\) is
  also a sheaf.
\end{prop}

Though we have these closure properties, we have not yet actually seen
any examples of sheaves.
%
For now, the only basic examples of sheaves we have are all related to
\(\IBoxSym\) stable propositions.

\begin{prop}\label{prop:t-stable-iff-sheaf}
  For \(P : \IProp\), the proposition \(\IImplies{\IBox{P}}{P}\) holds if and
  only if \(\IHolds{P}\) is a sheaf.
\end{prop}

\begin{coro}
  The unit type \(\mathbb{1}\) is a sheaf. The empty type
  \(\mathbb{0}\) is a sheaf if and only if \(\IBox{\bot} = \bot\).
\end{coro}

And for the first example of a sheaf which is not a proposition we
have the subtype of propositions which are \(\IBoxSym\)-stable.

\begin{defn}
  The \definiendum{subobject classifier of sheaves}, denoted \(\IPropCl\), is
  given by the subtype of \(\IBoxSym\)-stable propositions, more explicitly it
  is the dependent sum \((P : \IProp) \times \IHolds{\IImplies{\IBox{P}}{P}}\).
\end{defn}

\begin{prop}
  The type \(\IPropCl\) of \(\IBoxSym\)-stable propositions is a sheaf.
\end{prop}

\subsection{Sheafification}%
\label{sub:sheafification-internal}

We are now faced with the fact that there really are not any more sheaves we
can talk about internally, which leaves us at an impasse.
%
Luckily, we can burrow our way out, for we are taking our semantics in \(\E\),
where a myriad of sheaves exist.
%
In particular, for every object \(A\) in \(\E\) there exists a free sheaf on
\(A\); provided we can axiomatise this to a satisfactory degree we can then use
it inside the internal language to talk about many more examples of sheaves.

As usual, we characterise free constructions as left adjoints, so first we
assume we have a sheafification type former
\(\ISheafSym : \IUni \to \IUni\) such that for all \(a : A\), we have
\(\ILeafSym : A \to \ISheaf{A}\) and proof that \(\ISheaf{A}\) is a sheaf.
%
Our second requirement is that, given a type \(A\) and a sheaf \(B\), the
pre-composition map
\(-\circ\ILeafSym : (\ISheaf{A} \to B) \to (A \to B)\) is an equivalence.
%
Given \(f : A \to B\), we denote its transpose across the equivalence by
\(\ISheafExt{f} : \ISheaf{A} \to B\).

While this adjunction lets us define non-dependent maps out of sheafified
types, we would currently get stuck trying to prove any properties
about these maps.
%
For that, we need to recover a dependent elimination principle, which we
can do through the use of the total space of a type family.

\begin{prop}%
\label{prop:sheafification-elim-principle}
Given a type \(A\) and a type family \(F : \ISheaf{A} \to \IUni\) such that
\(Fd\) is a sheaf for all \(d : \ISheaf{A}\), then for any
\(f : (a : A) \to F(\ILeaf{a})\) there exists a unique function
\(\ISheafInd{f} : (d : \ISheaf{A}) \to Fd\) satisfying
\(f = \ISheafInd{f} \circ \ILeafSym\).
\end{prop}
\begin{proof}
  The adjunction only lets us transpose non-dependent maps out of \(A\),
  so we first define:
  \begin{align*}
    &s : A \to \IProd{(d : \ISheaf{A})}{Fd}\\
    &s\,a \IsDefined \IPair{\ILeaf{a}}{f\,a}
  \end{align*}
  %
  Since \(\ISheaf{A}\) is a sheaf, and so are all the fibers of \(F\), we know
  by~\Cref{prop:sums-preserve-sheaf} that the total space of \(F\) is a sheaf,
  hence we can take the transpose of \(s\) to get a map
  \(\ISheafExt{s} : \ISheaf{A} \to \IProd{(d : \ISheaf{A})}{Fd}\).
  %
  A quick computation shows that
  \(\IFst \circ \ISheafExt{s} \circ \ILeafSym = \IFst \circ s = \ILeafSym\),
  but pre-composition with \(\ILeafSym\) is an equivalence so that
  implies that \(\IFst \circ \ISheafExt{s}\) is the identity.
  %
  From the fact that \(\ISheafExt{s}\) is a section of \(\IFst\), we see that
  \(\ISnd \circ \ISheafExt{s}\) has the type required, so we are left to
  show the required equation.
  %
  This holds as we have~\(f = \ISnd \circ s = \ISnd \circ \ISheafExt{s} \circ \ILeafSym\).
  %
  For the uniqueness part suppose we have two candidates
  \(g,h : (d : \ISheaf{A}) \to Fd\) satisfying
  \(f = g\circ\ILeafSym = h\circ\ILeafSym\), then
  \(\IProd{\text{id}}{g} = \IProd{\text{id}}{h}\) because these agree on
  the image of \(\ILeafSym\).
  %
  But now
  \(g = \ISnd \circ (\IProd{\text{id}}{g}) = \ISnd \circ (\IProd{\text{id}}{h}) = h\) as needed.
\end{proof}

As a corollary of this elimination principle, we now see how to reason
about predicates on sheafified types.
%
In particular, we only have a good grasp on these if they are
\(\IBoxSym\)-stable.

\begin{coro}
  Given a predicate \(P : X \to \IPropCl\), if \(P x\) holds for all \(x : X\),
  then also \(\ISheafExt{P}d\) holds for all \(d : \ISheaf{X}\).
\end{coro}
\begin{proof}
  The type family
  \(F\,X \IsDefined \IHolds{P\,X}\) is fiberwise a sheaf, so we may
  apply~\Cref{prop:sheafification-elim-principle}.
\end{proof}

As we saw, the property of being a sheaf is a well-behaved one with respect
to constructors of type theory.
%
It is no surprise then that sheafification also seems to play well with these,
for example commuting with dependent sums and products.
%
The result for dependent sums will be of particular interest later since
we will use these to extend predicates to partial elements.

\begin{prop}
  Given a type \(A\) and a family \(F : \ISheaf{A} \to \IUni\) which is
  fiberwise a sheaf, then we have the following equivalences of types:
  %
  \begin{align*}
    \ISheaf{(\IProd{(a : A)}{F(\ILeaf{a})})}
    &\cong
    \IProd{(d : \ISheaf{A})}{F\,d}
    \\
    \ISheaf{(\IFun{(a : A)}{F(\ILeaf{a})})}
    &\cong
    \IFun{(d : \ISheaf{A})}{F\,d}
  \end{align*}
\end{prop}
\begin{proof}
  First we focus on the equivalence for dependent sums. For the forward
  direction, as \(F\) is fiberwise a sheaf, it suffices to give a map
  \(\IProd{(a : A)}{F(\ILeaf{a})} \to \IProd{(d : \ISheaf{A})}{F\,d}\).
  %
  This map is given coordinate wise as \(\IProd{\ILeafSym}{\text{id}}\).
  %
  For the reverse direction, by using the dependent elimination principle and
  uncurrying, all we are left to do is define a function
  \((a : A) \to F(\ILeaf{a}) \to \ISheaf{(\IProd{(a : A)}{F(\ILeaf{a})})}\).
  %
  For this we use \(\ILam{a:A}{\ILam{x:F(\ILeaf{a})}{\ILeaf{\IPair{a}{x}}}}\).
  %
  We are left to show that both round-trips are equal to the identity and
  for this we simply need to check them on the image of \(\ILeafSym\).
  %
  This amounts to the fact that for all \(a : A\) and \(x : F(\ILeaf{a})\)
  we have:

  \begin{minipage}[c]{0.25\textwidth}
    \begin{align*}
      &\ISheafExt{(\IProd{\ILeafSym}{\text{id}})}(\ILeaf{\IPair{a}{x}})
      \\
      &\quad=
        (\IProd{\ILeafSym}{\text{id}})\IPair{a}{x}
      \\
      &\quad=
        \IPair{\ILeaf{a}}{x}
    \end{align*}
  \end{minipage}
  \begin{minipage}[c]{0.74\textwidth}
    \begin{align*}
      &\text{uncurry}(\ISheafExt{(\ILam{a:A}{\ILam{x:F(\ILeaf{a})}{\ILeaf{\IPair{a}{x}}}})})\IPair{\ILeaf{a}}{x}
      \\
      &\quad=
        \ISheafExt{(\ILam{a:A}{\ILam{x:F(\ILeaf{a})}{\ILeaf{\IPair{a}{x}}}})}\,(\ILeaf{a})\,x
      \\
      &\quad=
        (\ILam{a:A}{\ILam{x:F(\ILeaf{a})}{\ILeaf{\IPair{a}{x}}}})\,a\,x
      \\
      &\quad=
        \ILeaf{\IPair{a}{x}}
    \end{align*}
  \end{minipage}

  \hspace{0pt}

  The ideas for the dependent product equivalence are similar.
  %
  For the forwards direction we use the extension \(\ISheafExt{\ISheafIndSym}\),
  while for the backwards directions we use the map
  \(\ILeafSym \circ (-\circ\ILeafSym)\).
  %
  First we check the forward then backwards round-trip: given some
  \(f : \ISheaf{(\IFun{(a:A)}{F(\ILeaf{a})})}\to\IFun{(d:\ISheaf{A})}{Fd}\),
  we have
  \(
    (\ISheafExt{\ISheafIndSym}(\ILeafSym (f\circ\ILeafSym)))
    =
    \ISheafInd{(f\circ\ILeafSym)}
  \).
  %
  To check the right-hand side equals \(f\), we can just check they agree
  when precomposed with \(\ILeafSym\).
  %
  This is true as
  \(\ISheafInd{(f\circ\ILeafSym)}\circ\ILeafSym = f\circ\ILeafSym\)
  holds by \Cref{prop:sheafification-elim-principle}.
  %
  For the other round-trip we again check that both maps
  agree when precomposed with \(\ILeafSym\): given
  \(f : \IFun{(a:A)}{F(\ILeaf{a})}\) we have
  %
  \(
    \ILeafSym{(\ISheafExt{\ISheafIndSym}(\ILeafSym{f})\circ\ILeafSym)}
    =
    \ILeafSym{(\ISheafInd{f}\circ\ILeafSym)}
    =
    \ILeafSym{f}
   \).
\end{proof}

\begin{prop}
  For a proposition \(P : \IProp\), its sheafification \(\ISheaf{\IHolds{P}}\)
  is equivalent as a type to~\(\IHolds{\IBox{P}}\).
\end{prop}
\begin{proof}
  First we define the forward direction
  \(f : \IHolds{\IBox{P}} \to \ISheaf{\IHolds{P}}\):
  %
  given \(q : \IHolds{\IBox{P}}\), since \(\ISheaf{\IHolds{P}}\) is a sheaf,
  we have the map
  \(\IGlue{\ISheaf{\IHolds{P}}}\,P\,q : (\IHolds{P} \to \ISheaf{\IHolds{P}}) \to \IHolds{P}\)
  so we set
  \(f(q) \IsDefined \IGlue{\ISheaf{\IHolds{P}}}\,P\,q\,\ILeafSym\).
  %
  For the backwards direction we wish to define
  \(g : \ISheaf{\IHolds{P}} \to \IHolds{\IBox{P}}\).
  %
  By~\Cref{prop:t-stable-iff-sheaf} we know that \(\IHolds{\IBox{P}}\)
  is a sheaf, so it suffices to define a map
  \(\IHolds{P} \to \IHolds{\IBox{P}}\) which follows from the
  definition of a Lawvere-Tierney topology.

  We must still check that both composites are equal to the identity.
  %
  The composite \(g\circ f\) is immediately equal to the identity as
  \(\IHolds{\IBox{P}}\) is a proposition.
  %
  As for \(f \circ g\), it suffices to check that
  \(f\circ g\circ \ILeafSym = \ILeafSym\).
  %
  So given \(p : \IHolds{P}\) we have:
  %
  \begin{align*}
    (f \circ g \circ \ILeafSym)\,p
    &=
      \IGlue{\ISheaf{\IHolds{P}}}\,P\,(gp)\,(\ILam{q:\IHolds{P}}{\ILeaf{q}})
    \\
    &=
      \IGlue{\ISheaf{\IHolds{P}}}\,P\,(gp)\,(\ILam{q:\IHolds{P}}{\ILeaf{p}})
    \\
    &=
      \ILeaf{p}
  \end{align*}
  %
  where in the first equality we simply unfolded definitions and did some
  \(\eta\)-expansion, the second equality holds as \(P\) is a proposition and so
  \(p = q\), and the third equality holds by the uniqueness condition of gluing.
\end{proof}

\begin{coro}
  Given a type \(A\) and a \(\IBoxSym\)-stable predicate
  \(P:A\to\IPropCl\), then we have
  %
  \[
    \IBox{(\IForall{a:A}{Pa})}
    \Leftrightarrow
    \IForall{d:\ISheaf{A}}{\ISheafExt{P}d}
  \]
  %
  In the case of a proposition \(Q:\IProp\) and
  a \(\IBoxSym\)-stable predicate \(P:\IHolds{Q}\to\IPropCl\), then we also have
  %
  \[
    \IBox{(\IExists{q:\IHolds{Q}}{Pq})}
    \Leftrightarrow
    \IExists{h:\IHolds{\IBox{Q}}}{\ISheafExt{P}q}
  \]
\end{coro}

\subsection{Lifting monad and partiality}

We may define the lifting monad in any topos internally, which will then
let us speak of partial functions --- a crucial ingredient of realizability
and even more so when we look at choice sequences.

\begin{defn}\label{defn:lifting}
  We define the \definiendum{lifting of a type \(X\)} as the dependent sum
  \(\IPar{X} \IsDefined \IProd{(P : \IProp)}{\IHolds{P}\to X}\).
  %
  Given an element \(x : \IPar{X}\) we denote its first projection by
  \(\ITotal{x} : \IProp\) and its second projection by
  \(\IVal{x}: \IHolds{\ITotal{x}} \to X\).
\end{defn}

\begin{prop}
  The lifting of a type \(\IPar{(-)}\) gives a monad.
\end{prop}

The monadic structure of partial elements is by itself not enough to get
a realizability tripos though, we must also know how to extend predicates on
a type \(X\) to predicates on its lifting.
%
This is the role of modal operators~\cite{moggiNotionsComputationMonads1991} and
modalities~\cite{cohenPartialMonadicCombinatory2025}.

\begin{prop}
  The function \(\ISquashSym : \IPar{\IProp} \to \IProp\) defined by
  sending
  %
  \(
    \ISquash{a} \IsDefined \IProd{(h:\IHolds{\ITotal{a}})}{\IHolds{\IVal{a}\,h}}
  \)
  %
  is an algebra for the lifting monad.
\end{prop}

\begin{defn}
  We define the \definiendum{lifting of a predicate \(P : X \to \IProp\)} as
  \(\IParExt{P} : \IPar{X} \to \IProp\) as the composite
  \(\ISquashSym\circ\IPar{P} : \IPar{X} \to \IPar{\IProp} \to \IProp\).
  %
  More explicitly, we have
  \(\IParExt{P}\,x\IsDefined \IProd{(h:\IHolds{\ITotal{Px}})}{\IHolds{\IVal{(Px)}\,h}}\).
\end{defn}



\newpage

\todo[inline]{blah blah}

While this principle is helpful, often we will also need to simplify
the extension of a predicate \(P : X \to \IPropCl\). For that, we have
the following commutation results:

\begin{prop}
  Given predicates \(P,Q : X \to \IPropCl\) and \(d : \ISheaf{X}\), we know  mthat
  %
  \[\begin{array}{rll}
    \ISheafExt{(\IAnd{P}{Q})}d &=& \IAnd{\ISheafExt{P}d}{\ISheafExt{Q}d} \\
    \ISheafExt{(\IBox{(\IOr{P}{Q})})}d &=& \IBox{(\IOr{\ISheafExt{P}d}{\ISheafExt{Q}d})}\\
    \ISheafExt{(\IImplies{P}{Q})}d &=& \IImplies{\ISheafExt{P}d}{\ISheafExt{Q}d}
  \end{array} \]
  %
Furthermore, for a stable proposition \(R : \IPropCl\), the extension of the
constant predicate \(\ILam{x:X}{R}\) is the constant predicate
\(\ILam{d:\ISheaf{X}}{R}\).
\end{prop}
\begin{proof}
  For all of these we will show that the left and right hand sides agree when
  precomposed with \(\ILeafSym\), then by the uniqueness of extensions the two
  must be equal.
  %
  Fixing \(x : X\), we then have
  \begin{gather*}
    \ISheafExt{(\IImplies{P}{Q})}(\ILeaf{x})
    = (\IImplies{P}{Q})(x)
    = \IImplies{P(x)}{Q(x)}
    = \IImplies{\ISheafExt{P}(\ILeaf{x})}{\ISheafExt{Q}(\ILeaf{x})}
    \\
    \ISheafExt{(\IAnd{P}{Q})}(\ILeaf{x})
    = (\IAnd{P}{Q})(x)
    = \IAnd{P(x)}{Q(x)}
    = \IAnd{\ISheafExt{P}(\ILeaf{x})}{\ISheafExt{Q}(\ILeaf{x})}
    \\
    \ISheafExt{(\lambda\_.P)}(\ILeaf{x})
    = (\lambda\_.P)(\ILeaf{x})
    = P
    =
  \end{gather*}
\end{proof}



\section{A Realizability Tripos}

In this section we fix a topos \(\mathcal{E}\) along with a Lawvere-Tierney
topology \(\Box : \Omega \to \Omega\) on this topos.
%
I believe for this definition \(\mathcal{E}\) can be an elementary topos,
but I am less sure how this works out once we start considering sheafification.
%
We give our definitions internally to \(\mathcal{E}\), letting us simplify
the proofs in this section.


\begin{defn}\label{defn:tripos-predicates-and-ordering}
  Given a presheaf \(\X\) we define the type of \definiendum{realizability
    predicates on \(\X\)} as the exponential \(\RealPred{\X}\).
  %
  We further define an ordering on realizability
  predicates~\(\varphi, \psi : \RealPred{\X}\) by
  %
  \[
    \varphi \leq \psi
    \IsDefined
    \IExists{e : \A}{
      \IForall{x : \X}{
        \IForall{a : \A}{
          \IImplies%
            {\varphi(a,x)}%
            {\IBox{(
              \IAnd%
              {\ITotal{\IAp{e}{a}}}%
              {\psi(\IAp{e}{a}, x)}
            )}}
        }
      }
    }
  \]
  %
  We will say that \definiendum{\(e\) evidences \(\varphi \leq \psi\)} if
  it witnesses the existential quantifier above.
\end{defn}

\begin{lemm}\label{lemm:tripos-preorder}
  For any presheaf \(\X\), \((\RealPred{\X}, \leq)\) is a preorder.
\end{lemm}
\begin{proof}
  Fix \(\varphi\), then \(\varphi \leq \varphi\) is always evidenced by
  \(\IIdentCode\).
  %
  Fix \(x : \X\) and \(a \in \varphi(x)\), since application of \(\IIdentCode\) is
  always well-defined and behaves as identity, it holds
  that~\(\ITotal{\IAp{\IIdentCode}{a}}\) and \({\IAp{\IIdentCode}{a}\in\varphi(x)}\).
  %
  This implies the necessary boxed statement to prove \(\leq\) reflexive.

  It is also transitive. Suppose that \(\varphi \leq \psi\) and
  \(\psi \leq \chi\) evidenced by \(e_{1}\) and \(e_{2}\) respectively.
  %
  Fixing \(x : \X\) and \(a \in \varphi(x)\), it follows by assumption that
  %
  \[
    \IBox{(
      \IAnd%
      {\ITotal{\IAp{e_{1}}{a}}}%
      {\IAp{e_{1}}{a} \in \psi(x)}
    )}
  \]
  %
  By monotonicity of \(\IBoxSym\) as well as our second assumption we may derive
  %
  \[
    \IBox{(
      \IAnd%
      {\ITotal{\IAp{e_{1}}{a}}}%
      {\IBox{[\IAnd%
        {\ITotal{\IAp{e_{2}}{(\IAp{e_{1}}{a})}}}%
        {\IAp{e_{2}}{(\IAp{e_{1}}{a})} \in \chi(x)}
      ]}}
    )}
  \]
  %
  As \(\IBoxSym\) is idempotent and preserves conjunctions we may simplify this
  to contain a single occurence of the modal box
  %
  \[
    \IBox{(
      \IAnd%
      {\ITotal{\IAp{e_{1}}{a}}}%
      {\IAnd%
        {\ITotal{\IAp{e_{2}}{(\IAp{e_{1}}{a})}}}%
        {\IAp{e_{2}}{(\IAp{e_{1}}{a})} \in \chi(x)}
      }
    )}
  \]
  %
  As needed, this is equivalent to saying that
  \(\IAp{\IAp{\ICompCode}{e_{1}}}{e_{2}}\) evidences \(\varphi \leq \chi\).
\end{proof}

\begin{lemm}\label{lemm:tripos-finite-meets}
  For any presheaf \(\X\), the preorder \((\RealPred{\X}, \leq)\) has finite
  meets.
  %
  The top element is described by~\ref{defn:tripos-top} and the meet of two
  realizability predicates~\(\varphi\) and \(\psi\) is described
  by~\ref{defn:tripos-binary-meet}:
  %
  \begin{gather}
    \TTop{\X}(x,a)
    \IsDefined
    \ITop
    \label{defn:tripos-top}
    \\
    (\TAnd{\varphi}{\psi}{\X})(x,a)
    \IsDefined
    \IAnd%
      {\IAnd{\ITotal{\IAp{\IFstCode}{a}}}{\varphi(x,\IAp{\IFstCode}{a})}}%
      {\IAnd{\ITotal{\IAp{\ISndCode}{a}}}{\psi(x,\IAp{\ISndCode}{a})}}
    \label{defn:tripos-binary-meet}
  \end{gather}
\end{lemm}
\begin{proof}
  We start by showing that \(\TTop{\X}\) is a greatest element.
  %
  Fixing \(\varphi:\RealPred{\X}\), then the identity code \(\IIdentCode\)
  evidences \(\varphi \leq \TTop{\X}\), as for all \(x : \X\) and
  \(a \in \varphi(x)\) we have \(\IAp{\IIdentCode}{a} = a\).

  Next we show \(\TAnd{\varphi}{\psi}{\X}\) is the meet of \(\varphi\) and
  \(\psi\) in \(\RealPred{\X}\).
  %
  The projection codes~\(\IFstCode\) and~\(\ISndCode\) evidence
  \(\TAnd{\varphi}{\psi}{\X}\leq\varphi\) and
  \(\TAnd{\varphi}{\psi}{\X}\leq\psi\) respectively:
  %
  if \((\TAnd{\varphi}{\psi}{\X})(x,a)\) then by definition we have
  \(\IAnd{\ITotal{\IAp{\IFstCode}{a}}}{\varphi(x,\IAp{\IFstCode}{a})}\), as
  well as the corresponding for \(\ISndCode\) and \(\psi\).
  %
  As for the elimination rule, suppose we have \(\chi\leq\varphi\) and
  \(\chi\leq\psi\) evidenced by \(e_{1}\) and \(e_{2}\) respectively,
  then~%
  %
  \(
    e \IsDefined
    \IAbs{a}{\IPAp{\IPAp{\IPairCode}{(\IPAp{e_{1}}{a})}}{(\IPAp{e_{1}}{a})}}
  \)
  %
  evidences \(\chi\leq\TAnd{\varphi}{\psi}{\X}\).
  %
  We know this by specialising our assumptions on~\(e_{1}\) and~\(e_{2}\) to a
  fixed \(x:\X\) and \(a:\A\) satisfying \(\chi(x,a)\), and commuting
  \(\IBoxSym\) with conjunctions, giving us
  %
  \[
    \IBox{
      (\IAnd{
        \IAnd{\ITotal{\IAp{e_{1}}{a}}}{\ITotal{\IAp{e_{2}}{a}}}
      }{
        \IAnd{\varphi(x,\IAp{e_{1}}{a})}{\psi(x,\IAp{e_{2}}{a})}
      })
    }
  \]
  %
  The first two conjuncts tell us that \(\ITotal{\IAp{e}{a}}\) and so by the
  specification of functional completeness we see that
  \(\IAp{e}{a} = \IAp{\IAp{\IPairCode}{(\IAp{e_{1}}{a})}}{(\IAp{e_{1}}{a})}\).
\end{proof}

\begin{lemm}\label{lemm:tripos-finite-joins}
  For any presheaf \(\X\), the preorder \((\RealPred{\X}, \leq)\) has finite
  joins.
  %
  The bottom element is described by~\ref{defn:tripos-bottom} and the join of two
  realizability predicates~\(\varphi\) and \(\psi\) is described
  by~\ref{defn:tripos-binary-join}:
  %
  \begin{gather}
    \TBot{\X}(x,a)
    \IsDefined
    \IBot
    \label{defn:tripos-bottom}
    \\
    (\TOr{\varphi}{\psi}{\X})(x,a)
    \IsDefined
    \IExists{b:\A}{\IOr%
      {(\IAnd{\IEq{a}{\IAp{\ILeftCode}{b}}}{\varphi(x,b)})}%
      {(\IAnd{\IEq{a}{\IAp{\IRightCode}{b}}}{\psi(x,b)})}
    }
    \label{defn:tripos-binary-join}
  \end{gather}
\end{lemm}
\begin{proof}
  First we see that \(\TBot{\X}\) is indeed the bottom element, but any code
  \(e : \A\) vacuously evidences the inequality \(\TBot{\X} \leq \phi\).

  Now let us see that \(\TOr{\varphi}{\psi}{\X}\) is indeed the required join.
  %
  The introduction rules \(\varphi\leq\TOr{\varphi}{\psi}{\X}\) and
  \(\psi\leq\TOr{\varphi}{\psi}{\X}\) are evidenced by \(\ILeftCode\) and
  \(\IRightCode\) respectively.
  %
  To prove the former, fix \(x:\X\) and \(a:\A\) such that \(\varphi(x,a)\),
  then we always have \(\ITotal{\IAp{\ILeftCode}{a}}\) and hence
  \((\TOr{\varphi}{\psi}{\X})(x,\IAp{\ILeftCode}{a})\).
  %
  \(\Box\) is inflationary so this finishes the proof and we note that the case
  for \(\IRightCode\) follows similarly.
  %
  As for the elimination rule, suppose that \(e_{0}\) evidences
  \(\varphi \leq \chi\) and \(e_{1}\) evidences \(\psi \leq \chi\), then
  \(\IAp{\IAp{\IMatchCode}{e_{0}}}{e_{1}}\) will evidence
  \(\TOr{\varphi}{\psi}{\X} \leq \chi\).
  %
  In fact, fix \(x:\X\) and \(a:\A\) such that
  \((\TOr{\varphi}{\psi}{\X})(x,a)\), then there exists some \(b:\A\) such that
  either \(\IEq{a}{\IAp{\ILeftCode}{b}}\) and \(b\in\varphi(x)\), or
  \(\IEq{a}{\IAp{\IRightCode}{b}}\) and \(b\in\psi(x)\).
  %
  In the first case, we have that
  %
  \(\IPLeq%
  {\IAp{e_{0}}{b}}%
  {\IAp{\IAp{\IAp{\IMatchCode}{e_{0}}}{e_{1}}}{(\IAp{\IRightCode}{b})}}%
  \)
  %
  and \(\IBox{(\IAnd{\ITotal{\IAp{e_{0}}{b}}}{\chi(\IAp{e_{0}}{b},x)})}\),
  from which we can show that
  %
  \(\IBox{(\IAnd%
    {\ITotal{\IAp{\IAp{\IAp{\IMatchCode}{e_{0}}}{e_{1}}}{a}}}%
    {\chi(\IAp{\IAp{\IAp{\IMatchCode}{e_{0}}}{e_{1}}}{a},x)}%
  )}\).
  %
  The right case follows analogously.
\end{proof}

\begin{lemm}\label{lemm:tripos-heyting-implication}
  For any presheaf \(\X\), \((\RealPred{\X}, \leq)\) has Heyting
  implication described by
  \begin{gather}
    (\TImplies{\varphi}{\psi}{\X})(x,a)
    \IsDefined
    \IForall{b : \A}{%
      \IImplies%
      {\varphi(x,b)}%
      {\IBox{(%
          \IAnd%
          {\ITotal{\IAp{a}{b}}}%
          {\psi(x,\IAp{a}{b})}
    )}}}
    \label{defn:tripos-heyting-implication}
  \end{gather}
\end{lemm}
\begin{proof}
  Suppose that \(\TAnd{\varphi}{\psi}{\X} \leq \chi\) is evidenced by \(e\),
  then \(\varphi \leq \TImplies{\psi}{\chi}{\X}\) is realized by the code
  \(\IAbs{a}{\IAbs{b}{\IPAp{e}{(\IPAp{\IPAp{\IPairCode}{a}}{b})}}}\).
  %
  Fixing \(x : \X\) and \(a : \A\) such that \(\varphi(x,a)\), we have
  %
  \[\IEq%
  {\IAp{(\IAbs{a}{\IAbs{b}{\IPAp{e}{(\IPAp{\IPAp{\IPairCode}{a}}{b})}}})}{a}}%
  {\IAbs{b}{\IPAp{e}{(\IPAp{\IPAp{\IPairCode}{a}}{b})}}}%
  \]
  %
  leaving us to prove that
  %
  \(
  (\TImplies{\psi}{\chi}{\X})%
  (x, \IAbs{b}{\IPAp{e}{(\IPAp{\IPAp{\IPairCode}{a}}{b})}})%
  \).
  %
  For this, fix \(b : \A\) and assume \(\psi(x,b)\), then we know that
  %
  \(\IPLeq%
  {\IPAp{e}{(\IPAp{\IPAp{\IPairCode}{a}}{b})}}%
  {\IAp{(\IAbs{b}{\IPAp{e}{(\IPAp{\IPAp{\IPairCode}{a}}{b})}})}{b}}\).
  %
  From \(\varphi(x,a)\) and \(\psi(x,b)\) we know that
  \((\TAnd{\varphi}{\psi}{\X})(x,\IPAp{\IPAp{\IPairCode}{a}}{b})\) and hence
  %
  \(\IBox{(%
    \IAnd%
    {\ITotal{\IAp{e}{\IPAp{\IPAp{\IPairCode}{a}}{b}}}}%
    {\psi(x,\IAp{e}{(\IPAp{\IPAp{\IPairCode}{a}}{b})})})}%
  \)
  %
  as needed.

  For the converse direction suppose that
  \(\varphi \leq \TImplies{\psi}{\chi}{\X}\) is evidenced by \(e\), then
  \(\TAnd{\varphi}{\psi}{\X} \leq \chi\) will be evidenced by
  \(\IAbs{a}{\IPAp{\IPAp{e}{(\IPAp{\IFstCode}{p})}}{(\IPAp{\ISndCode}{p})}}\).
  %
  We fix \(x : \X\) and \(a : \A\) and assume \((\TAnd{\varphi}{\psi})(x,a)\),
  which implies \(\ITotal{\IPAp{\IFstCode}{p}}\),
  \(\ITotal{\IPAp{\ISndCode}{p}}\) and both \(\varphi(x,\IPAp{\IFstCode}{p})\)
  and \(\psi(x,\IPAp{\ISndCode}{p})\).
  %
  From this we get that
  %
  \[
    \IBox{[\IAnd%
    {\ITotal{\IPAp{e}{(\IPAp{\IFstCode}{p})}}}%
    {(\TImplies{\psi}{\chi}{\X})(x,\IPAp{e}{(\IPAp{\IFstCode}{p})})}%
    ]}
  \]
  %
  but \((\TImplies{\psi}{\chi}{\X})(x,\IPAp{e}{(\IPAp{\IFstCode}{p})})\) and
  \(\varphi(x,\IPAp{\IFstCode}{p})\) together imply
  %
  \[
    \IBox{[\IAnd%
    {\ITotal{\IPAp{\IPAp{e}{(\IPAp{\IFstCode}{p})}}{(\IPAp{\ISndCode}{p})}}}%
    {\chi(x,\IPAp{\IPAp{e}{(\IPAp{\IFstCode}{p})}}{(\IPAp{\ISndCode}{p})})}%
    ]}
  \]
  and so monotonicity and idempotence of \(\IBoxSym\) let us string
  these two implications together.
\end{proof}

\todo[inline,caption={}]{
 type up the following from notes:
 \begin{itemize}
   \item define pullback and show it is heyting algebra morphism
   \item prove left adjoint to pullback exists (as monotone map)
   \item prove right adjoint to pullback exists (as monotone map)
   \item prove beck-chevalley condition
   \item show there is a generic object
 \end{itemize}
}

\subsection{The need for a modality}

One approach we could try would be to keep the typical ordering
used in realizability, that is without a modality:
%
\[
    \varphi \leq' \psi
    \IsDefined
    \IExists{e : \A}{
      \IForall{x : \X}{
        \IForall{a : \A}{
          \IImplies%
            {\varphi(a,x)}%
            {\IAnd%
              {\ITotal{\IAp{e}{a}}}%
              {\psi(\IAp{e}{a}, x)}
            }
        }
      }
    }
\]
%
From here we would hope to find an appropriate monad \(T : \AsmCat \to \AsmCat\)
on assemblies and use its Kleisli category for semantics.

Given an assembly \((X,\varphi)\), denote its underlying
object of \(T(X,\varphi)\) by \(X_{T}\) and its realizability relation
by \(\varphi_{T}:\RealPred{X_{T}}\).
%
With this notation fixed, a morphism between \((X,\varphi)\) and \((Y,\psi)\) in
the Kleisli category of \(T\) would then consist of a morphism
\(f : X \to Y_{T}\) in the underlying category \(\E\) satisfying
\(\varphi \leq' \TPull{f}\psi\).
%
This requirement on \(f\) unfolds to
%
\[
  \IExists{e : \A}{
    \IForall{x : \X}{
      \IForall{a : \A}{
        \IImplies%
          {\varphi(a,x)}%
          {\IAnd%
            {\ITotal{\IAp{e}{a}}}%
            {\psi_{T}(\IAp{e}{a}, f(x))}
          }
      }
    }
  }
\]
%
What becomes clear now is that the requirement that \(\IAp{e}{a}\)
be defined sits outside the purview of the monad \(T\)
%
In particular, regardless of the effect on \(X_{T}\) and \(\varphi_{T}\), we
still require \(\ITotal{\IAp{e}{a}}\) with no alterations.
%
In the presheaf case this amounts to requiring that \({e}\cdot_{w}{a}\)
be defined, instead of asking that there exist a bar \(U\) of \(w\)
such that \({e}\cdot_{u}{a}\) is defined for all \(u \in U\).

\subsection{Alternative Definitions}

We have been very particular with where we use the modality \(\Box\) in the
ordering of realizability predicates, but there are certainly other options.
%
We spend a bit of time now considering said options and their logical strength,
to convince you dear reader that ours is the most canonical.

%\begin{gather}
%    \IExists{e : \A}{
%      \IForall{x : \X}{
%        \IForall{a : \A}{
%          \IImplies%
%            {\varphi(a,x)}%
%            {(
%              \IAnd%
%              {\ITotal{\IAp{e}{a}}}%
%              {\psi(\IAp{e}{a}, x)}
%            )}
%        }
%      }
%    }
%    \\
%    \IExists{e : \A}{
%      \IForall{x : \X}{
%        \IForall{a : \A}{
%          \IImplies%
%            {\varphi(a,x)}%
%            {\IBox{(
%              \IAnd%
%              {\ITotal{\IAp{e}{a}}}%
%              {\psi(\IAp{e}{a}, x)}
%            )}}
%        }
%      }
%    }
%    \\
%    \IExists{e : \A}{
%      \IForall{x : \X}{
%        \IForall{a : \A}{
%          \IImplies%
%            {\IBox{(\varphi(a,x))}}%
%            {(
%              \IAnd%
%              {\ITotal{\IAp{e}{a}}}%
%              {\psi(\IAp{e}{a}, x)}
%            )}
%        }
%      }
%    }
%    \\
%    \IExists{e : \A}{
%      \IForall{x : \X}{
%        \IForall{a : \A}{
%          \IBox{(\IImplies%
%            {\varphi(a,x)}%
%            {(
%              \IAnd%
%              {\ITotal{\IAp{e}{a}}}%
%              {\psi(\IAp{e}{a}, x)}
%            )})
%        }}
%      }
%    }
%    \\
%    \IBox{(\IExists{e : \A}{
%      \IForall{x : \X}{
%        \IForall{a : \A}{
%          \IBox{(\IImplies%
%            {\varphi(a,x)}%
%            {(
%              \IAnd%
%              {\ITotal{\IAp{e}{a}}}%
%              {\psi(\IAp{e}{a}, x)}
%            )})
%        }}
%      }
%    })}
%    \\
%    \IBox{(\IExists{e : \A}{
%      \IForall{x : \X}{
%        \IForall{a : \A}{
%          \IImplies%
%            {\varphi(a,x)}%
%            {(
%              \IAnd%
%              {\ITotal{\IAp{e}{a}}}%
%              {\psi(\IAp{e}{a}, x)}
%            )}}
%      }
%    })}
%\end{gather}

First it is helpful to see how \(\IBoxSym\) interacts with Heyting implication.
%
If we have a single implication \(\IImplies{A}{B}\) then there are 3 positions
in which we can place a \(\IBoxSym\), namely in front of the \(A\), in front
of the \(B\) and surrounding the whole implication.
%
Furthermore, as the modality is idempotent, we only need to consider at most
one box in each position.
%
This leaves us with eight possibilities, four of which turn out to be
equivalent.
%
We display all of these below, with the arrows displaying logical implication.
%
\begin{center}
\begin{tikzpicture}
  \node (a) at (-4.5,3) {\(\IImplies{A}{\IBox{B}}\)};
  \node (b) at (-1.5,3) {\(\IImplies{\IBox{A}}{\IBox{B}}\)};
  \node (c) at (1.5,3) {\(\IBox{(\IImplies{\IBox{A}}{\IBox{B}})}\)};
  \node (d) at (4.5,3) {\(\IBox{(\IImplies{A}{\IBox{B}})}\)};
  \node (e) at (0,2) {\(\IBox{(\IImplies{A}{B})}\)};
  \node (f) at (-1.5,1) {\(\IImplies{A}{B}\)};
  \node (g) at (1.5,1) {\(\IBox{(\IImplies{\IBox{A}}{B})}\)};
  \node (h) at (0,0) {\(\IImplies{\IBox{A}}{B}\)};

  \draw[->] (h) -- (f);
  \draw[->] (h) -- (g);
  \draw[->] (f) -- (e);
  \draw[->] (g) -- (e);
  \draw[->] (e) -- (a);
  \draw[->] (e) -- (b);
  \draw[->] (e) -- (c);
  \draw[->] (e) -- (d);
  \draw[<->] (a) -- (b);
  \draw[<->] (b) -- (c);
  \draw[<->] (c) -- (d);
\end{tikzpicture}
\end{center}
%
\todo[inline]{I think we may also have that \(\IBox{(\IImplies{A}{B})}\) and
  \(\IBox{(\IImplies{\IBox{A}}{B})}\) are equivalent to the top formulas.}
%
%\begin{center}
%\begin{tikzpicture}
%
%  \node (b) at (13,0) {\(\IBox{(\IImplies{\IBox{A}}{\IBox{B}})}\)};
%  \node (d) at (11,1) {\(\IBox{(\IImplies{A}{\IBox{B}})}\)};
%  \node (f) at (11,-1) {\(\IBox{(\IImplies{\IBox{A}}{B})}\)};
%  \node (e) at (8,1) {\(\IBox{(\IImplies{A}{B})}\)};
%  \node (c) at (8,-1) {\(\IImplies{\IBox{A}}{\IBox{B}}\)};
%  \node (a) at (6,0) {\(\IImplies{A}{\IBox{B}}\)};
%
%  \node (g) at (4,0) {\(\IImplies{A}{B}\)};
%
%  \node (h) at (2,0) {\(\IImplies{\IBox{A}}{B}\)};
%
%  \draw[->] (h) -- (g);
%  \draw[->] (g) -- (a);
%  \draw[<->] (a) -- (e);
%  \draw[<->] (e) -- (d);
%  \draw[<->] (d) -- (b);
%  \draw[<->] (b) -- (f);
%  \draw[<->] (f) -- (c);
%  \draw[<->] (c) -- (a);
%\end{tikzpicture}
%\end{center}
%
The usual definition of implication in realizability uses Heyting implication
without any boxes, which turns out to be too strong a statement in our setting.
%
The above shows there is only one way of weakening an implication with
\(\IBoxSym\).
%
The usual definition of implication in realizability uses Heyting implication
without any boxes, which turns out to be too strong a statement in our setting.
%
The above shows that we have two possible ways of relaxing this, and
we have chosen the most liberal of the two options.

We also know that \(\IBoxSym\) commutes with universal quantification, i.e.\ the
formulas \(\IBox{(\IForall{y:Y}{A(y)})}\) and \(\IForall{y:Y}{\IBox{A(y)}}\) are
logically equivalent.
%
This means that, were we to place any boxes around the universal quantifiers,
we could commute them all inwards, until they would be absorbed
by our weakening of Heyting implication.

This leaves us with the final question: should we put a \(\IBoxSym\) around
the existential quantifier or not.
%
Unlike boxing the universal quantifiers, this would give us a genuinely weaker
logical statement, so it could be worthwhile.
%
However, it arguable weakens the statement too far, as it means that
the code \(e\) is no longer uniform in worlds when working in a
category of presheaves, at which point it seems we could just sheafify
our pca and work internally to the relevant category of sheaves.


\subsection{Totality}

When defining assemblies we will be particularly interested in total
predicates.

\begin{defn}\label{defn:tripos-total-predicates}
  A realizability predicate \(\varphi : \RealPred{X}\) is \definiendum{total}
  if it satisfies \(\IForall{x:X}{\IExists{a:\A}{\varphi(x,a)}}\).
\end{defn}

Building new total predicates is not particularly difficult as shown by
the following lemmas.
%
These will be enough to show that most standard constructions in the
category of assemblies have total predicates as needed.

\begin{lemm}\label{lemm:pullback-preserves-total}
  Given \(\varphi : \RealPred{Y}\) and a map \(f : X \to Y\), if
  \(\varphi\) is total then so is \(\TPull{f}\varphi\).
\end{lemm}
\begin{proof}
  Fix \(x:X\), by totality of \(\varphi\) we have some \(a:\A\) such that
  \(\varphi(f(x),a)\).
  %
  By definition, this is the same as saying \((\TPull{f}\varphi)(x,a)\) so
  pullback preserves totality.
\end{proof}

\begin{lemm}\label{lemm:top-total}
  The predicate \(\TTop{X}\) is always total.
\end{lemm}
\begin{proof}
  This is equivalent to showing that \(\A\) is inhabited, but a pca
  comes equipped with two distinguished elements so this is always the case.
\end{proof}

\begin{lemm}\label{lemm:meet-total}
  Two predicates \(\varphi,\psi : \RealPred{X}\) are total if and only if their
  meet \(\TAnd{\varphi}{\psi}{X}\) is total.
\end{lemm}
\begin{proof}
  For the forward direction, for a given \(x:X\) we have \(a:\A\) and \(b:\A\)
  such that \(\varphi(x,a)\) and \(\psi(x,b)\) and this means that
  \((\TAnd{\varphi}{\psi}{X})(x,\IAp{\IAp{\IPairCode}{a}}{b})\).
  %
  For the backwards direction, if we have \((\TAnd{\varphi}{\psi}{X})(x,a)\)
  then we also have \(\varphi(x,\IAp{\IFstCode}{a})\) and
  \(\psi(x,\IAp{\ISndCode}{a})\), so both \(\varphi\) and \(\psi\) are total.
\end{proof}

\begin{lemm}\label{lemm:join-total}
  Given two predicates \(\varphi,\psi : \RealPred{X}\), at least one of them is
  total if and only if their join \(\TOr{\varphi}{\psi}{X}\) is total.
\end{lemm}
\begin{proof}
  For the forward direction we suppose that \(\varphi\) is total
  and fix some \(x:X\).
  %
  By totality of \(\varphi\) we have \(a:\A\) such that
  \(\varphi(x,a)\), so then \((\TOr{\varphi}{\psi}{X})(x,\IAp{\ILeftCode}{a})\)
  which shows that \(\TOr{\varphi}{\psi}{X}\) is total.
  %
  In the case that \(\psi\) is total the proof follows analogously.
  %
  For the converse, fix \(x : X\), then by totality of the join
  of \(\varphi\) and \(\psi\) we have some \(a:\A\) such that
  \((\TOr{\varphi}{\psi}{X})(x,a)\).
  %
  By definition, this means that there exists \(b:\A\) such that either
  \(a = \IAp{\ILeftCode}{b}\) and \(\varphi(x,b)\), in which case \(\varphi\) is
  total, or \(a = \IAp{\IRightCode}{b}\) and \(\psi(x,b)\), in which case
  \(\psi\) is total.
\end{proof}

\begin{lemm}\label{lemm:bot-total}
  The predicate \(\TBot{X}\) is total if and only if
  \(\INot{(\IExists{x:X}\ITop)}\) holds, or equivalently,
  if \(X\) is an initial object of \(\E\).
\end{lemm}
\begin{proof}
  First we prove that totality of \(\TBot{X}\) is equivalent to
  \(\INot{(\IExists{x:X}\ITop)}\).
  %
  To do so, notice that
  \(\IForall{x:X}{\IExists{a:\A}{\TBot{X}(x,a)}}\)
  unfolds to
  \(\IForall{x:X}{\IExists{a:\A}{\IBot}}\),
  and that is equivalent to
  \(\IForall{x:X}{\IBot}\).
  %
  In turn, this is equivalent to the necessary condition.

  For the second equivalence, that \(\INot{(\IExists{x:X}\ITop)}\)
  holds if and only if \(X\) is initial, we use the Kripke-Joyal semantics
  in \(\E\).
  %
  Doing so, we see the foregoing statement holds if and only if whenever we have
  a span \(X \overset{x}{\leftarrow} Z \overset{p}{\twoheadrightarrow} Y\) with
  \(p\) an epimorphism, then \(Y\) is itself initial.
  %
  For the forward direction we have the span
  \(X \leftarrow X \twoheadrightarrow X\) where all maps are the identity,
  so by assumption \(X\) is initial.
  %
  For the converse, assume \(X\) is initial and we have a span
  \(X \overset{x}{\leftarrow} Z \overset{p}{\twoheadrightarrow} Y\).
  %
  Initial objects in a topos are strict, hence \(Z\) is also a strict initial
  object.
  %
  Any map out of a strict initial object is monic, so \(p\) is both
  monic and epic, which in a topos implies it is an isomorphism.
  %
  As \(Y\) is isomorphic to an initial object, it must also be initial
  as needed.
\end{proof}

\subsection{Presheaves with a Lawvere-Tierney Topology}

\todo[inline]{adapt to use new realizability predicate type}

Fix two realizability predicates \(\phi,\psi : \RealPred{\X}\), that is global
elements \(\phi,\psi : 1 \to \RealPred{\X}\).
%
We will unfold the denotation of \(\phi \leq \psi\) in the case of a preasheaf
category with some Lawvere-Tierney topology \(j : \Omega \to \Omega\).
%
We are, of course, interested in the following mono
%
\[
  \llbracket
    \IExists{e : \A}{
      \IForall{x : \X}{
        \IForall{a \in \varphi(x)}{
          \IBox{(
            \IAnd%
            {\ITotal{\IAp{e}{a}}}%
            {\IAp{e}{a} \in \psi(x)}
          )}
        }
      }
    }
  \rrbracket : \cdot \hookrightarrow 1
\]
%
We interpret the existential along the projection \(\pi_{\A} : 1 \times \A \to 1\)
giving us
%
\[
  \exists_{\pi_{\A}}(\underbrace{\llbracket
    \IForall{x : \X}{
      \IForall{a \in \varphi(x)}{
        \IBox{(
          \IAnd%
          {\ITotal{\IAp{e}{a}}}%
          {\IAp{e}{a} \in \psi(x)}
        )}
      }
    }
  \rrbracket}_{\text{subobject of }1 \times A})
\]
%
We interpret the universal along the projection
\(\pi_{\X} : (1 \times \A) \times \X \to 1 \times \A\) giving
%
\[
  \exists_{\pi_{\A}}\circ\forall_{\pi_{\X}}(\underbrace{\llbracket
    \IForall{a \in \varphi(x)}{
      \IBox{(
        \IAnd%
        {\ITotal{\IAp{e}{a}}}%
        {\IAp{e}{a} \in \psi(x)}
      )}
    }
  \rrbracket}_{\text{subobject of }(1 \times A) \times \X})
\]
%
Next we need to interpret the relative universal quantifier.
%
For this, the denotation of the open term
\(e : \A, x : \X \vdash \phi(x) : \IPower{\A}\) gives us a mono
%
\(
  m :
  S \hookrightarrow ((1 \times \A) \times \X) \times \A
\)
%
and composing this with the projection
\(\pi'_{\A} : ((1 \times \A) \times \X) \times \A \to (1 \times \A) \times \X\)
will give us the map along which we will interpret the quantifier.
%
\[
  \exists_{\pi_{\A}}\circ
  \forall_{\pi_{\X}}\circ
  \forall_{\pi'_{\A}\circ m}(\underbrace{\llbracket
    \IBox{(
      \IAnd%
      {\ITotal{\IAp{e}{a}}}%
      {\IAp{e}{a} \in \psi(x)}
    )}
  \rrbracket}_{\text{subobject of } S})
\]
%
Quantifiers are functorial so this is equivalent to the following
statement with a single universal
%
\[
  \exists_{\pi_{\A}}\circ
  \forall_{\pi_{\X}\circ\pi'_{\A}\circ m}(\underbrace{\llbracket
    \IBox{(
      \IAnd%
      {\ITotal{\IAp{e}{a}}}%
      {\IAp{e}{a} \in \psi(x)}
    )}
  \rrbracket}_{\text{subobject of } S})
\]
%
The modality is interpeted by taking the closure of the subobjects arising
out of the Lawvere-Tierney topology \(j:\Omega\to\Omega\).
%
\[
  \exists_{\pi_{\A}}\circ
  \forall_{\pi_{\X}}\circ
  \forall_{\pi'_{\A}\circ m}
  (\overline{\underbrace{\llbracket
      \IAnd%
      {\ITotal{\IAp{e}{a}}}%
      {\IAp{e}{a} \in \psi(x)}
  \rrbracket}_{\text{subobject of } S}})
\]
%
Conjunction is interpreted by the meet of subobjects. Such meets are computed
by pointwise intersections, but we can safely ignore that for now.
%
\[
  \exists_{\pi_{\A}}\circ
  \forall_{\pi_{\X}\circ\pi'_{\A}\circ m}
  \underset{\text{both subobjects of } S}%
  {(\overline{\underbrace{\llbracket \ITotal{\IAp{e}{a}}\rrbracket}
   \wedge
   \underbrace{\llbracket\IAp{e}{a} \in \psi(x)\rrbracket}
  })}
\]
%
At this point let us see how to interpret the particular terms mentioned.
%
We interpret the term \(e : \A, x : \X \vdash \phi(x) : \IPower{\A} \) as a
morphism \((1 \times \A) \times \X \to \IPower{\A}\) given by preocomposing
\(\EEval : X \times \RealPred{\X}\) with the pairing of the projection
\((1 \times \A) \times \X \to \X\) and of the map
\((1 \times \A) \times \X \to \RealPred{\X}\) which we get by weakening
\(\phi : 1 \to \RealPred{\X}\).
%
For clarity, the natural transformation \(\EEval\) is given by
%
\begin{align*}
  &\EEval_{w} : \X_{w} \times \mathsf{Nat}(\yo(w) \times \X, \IPower{\A})
                \to \IPower{\A}_{w}\\
  &\EEval_{w}(x, \alpha) = \alpha_{w}(\mathsf{id}, x)
\end{align*}
%
meaning that the denotation \(\llbracket\phi(x)\rrbracket\) is given by
%
\begin{align*}
  &\llbracket\phi(x)\rrbracket_{w} : (1 \times \A) \times \X \to \IPower{\A}\\
  &\llbracket\phi(x)\rrbracket_{w}((\star, a), x) =
    \EEval_{w}(x, \phi_{w}) = \phi_{w}(\mathsf{id}, x)
\end{align*}
%
Naturality in this case means that for any \(f : u \to w\), \(g : v \to u\)
and \(x : \X_{u}\) we have
\[
  (\alpha_{u}(f, x))\{g\} = \alpha_{v}(fg, x\{g\})
\]


\[
  ([\alpha_{v}(fg, x\{g\})]_{u}(f, a)) = \alpha_{v}(fg, x\{g\})
\]

We can now define the mono \(m\) from \(\llbracket\phi(x)\rrbracket\) as
the mono corresponding to the characteristic function
\(\chi_{m} : (1 \times \A) \times \X \to \Omega\) arising by precomposing
with the interpretations of \(e : \A, x : \X \vdash a : \A  \)
and the weakening of \(e : \A, x : \X \vdash \phi(x) : \IPower{\A}\).
%
In the end this means that we have
\[
  (((\star, e), x), a) \in \mathsf{domain}(m)_{w}
  \iff
  w \in [\phi_{w}(\mathsf{id}, x)]_{w}(\mathsf{id}, a)
\]

\dots

And this leads us to the following external definition of the ordering
on realizability predicates.

\begin{defn}
  We say that \(\phi \leq \psi\) at world \(w\) if there exists a code
  \(e : \A_{w}\) such that for all maps \(f : u \to w\), elements
  \(x : \X_{u}\) and codes \(a : \A_{u}\), if
  %
  \[
    \mathsf{id}_{u} \in [\phi_{u}(\mathsf{id}_{u}, x)]_{u}(\mathsf{id}_{u},a)
  \]
  %
  then there exists a cover \(\mathcal{V}\) of \(u\) such that for all
  \((g : v \to u) \in \mathcal{V}\) we have
  %
  \[\begin{array}{ccc}
  e\{fg\} \cdot_{v} a\{g\} \downarrow &\text{ and }&
  \mathsf{id}_{v} \in [\psi_{v}(\mathsf{id}_{v}, x\{g\})]_{v}(\mathsf{id}_{v},e\{fg\} \cdot_{v} a\{g\}).
  \end{array}\]
\end{defn}

In the case that the underlying category is a poset
%
\begin{defn}[Over a poset]
  We say that \(\phi \leq \psi\) at world \(w\) if there exists a code
  \(e : \A_{w}\) such that for all extensions \(u \leq w\), elements
  \(x : \X_{u}\) and codes \(a : \A_{u}\), if
  %
  \[
    u \in [\psi_{u}(u\leq u, x)]_{u}(u \leq u,a)
  \]
  %
  then there exists a cover \(\mathcal{V}\) of \(u\) such that for all \(v \in \mathcal{V}\) we
  have
  %
  \[\begin{array}{ccc}
    e|_{v} \cdot_{v} a|_{v} \downarrow &\text{ and }&
    v \in [\psi_{v}(v\leq v, x|_{v})]_{v}(v \leq v,e|_{v} \cdot_{v} a|_{v})
  \end{array}\]
\end{defn}

And further assuming that \(\A\) is a constant presheaf we get
%
\begin{defn}[Over a poset with constant \(\A\)]
  We say that \(\phi \leq \psi\) at world \(w\) if there exists a code
  \(e : \A\) such that for all extensions \(u \leq w\), elements
  \(x : \X_{u}\) and codes \(a : \A\), if
  %
  \[
    u \in [\phi_{u}(u\leq u, x)]_{u}(u \leq u,a)
  \]
  %
  then there exists a cover \(\mathcal{V}\) of \(u\) such that for all \(v \in \mathcal{V}\) we
  have
  %
  \[\begin{array}{ccc}
    e \cdot_{v} a \downarrow &\text{ and }&
    v \in [\psi_{v}(v\leq v, x|_{v})]_{v}(v \leq v,e \cdot_{v} a)
  \end{array}\]
\end{defn}

We can also work with uncurried predicates, so now we have
\(\phi,\psi : \IPower{(\X\times\A)}\), the previous assumptions and if we
also omit the proofs that specific worlds are extensions of others, then
we get the following definition, which is what we have been working with
already:
%
\begin{defn}[Lots of simplifications]
  We say that \(\phi \leq \psi\) at world \(w\) if there exists a code
  \(e : \A\) such that for all extensions \(u \leq w\), elements
  \(x : \X_{u}\) and codes \(a : \A\), if
  %
  \[
    u \in \phi_{u}(x, a)
  \]
  %
  then there exists a cover \(\mathcal{V}\) of \(u\) such that for all \(v \in \mathcal{V}\) we
  have
  %
  \[\begin{array}{ccc}
    e \cdot_{v} a \downarrow &\text{ and }&
    v \in \psi_{v}(x|_{v}, e \cdot_{v} a)
  \end{array}\]
\end{defn}

\section{Realizability Categories}%
\label{sec:realizability-categories}

With a tripos we can now define its associated category of assemblies
and realizability topos.

\subsection{Assemblies}%
\label{sub:assemblies}

\begin{defn}\label{defn:assembly}
  An \definiendum{assembly} is an object \(X\) of \(\E\) with a realizability
  predicate \(\varphi : \RealPred{X}\) satisfying the following internal
  statement \(\IForall{x:X}{\IExists{a:A}{\varphi(x,a)}}\).
  %
  We call such a predicates \definiendum{total}.
\end{defn}

\begin{defn}\label{defn:assembly-morphism}
  A \definiendum{morphism of assemblies} from \((X,\varphi)\) to
  \((Y,\psi)\) consists of a morphism \(f : X \to Y\) in \(\E\) such that
  \(\varphi \leq \TPull{f}\psi\). When \(\varphi \leq \TPull{f}\psi\) holds
  we say that \(f\) is \definiendum{tracked}.
\end{defn}

\begin{remk}
  Using the internal language of \(\E\), \(f : X \to Y\) is tracked as above
  if we have
  %
  \[
    \IExists{e : \A}{
      \IForall{x : \X}{
        \IForall{a : \A}{
          \IImplies%
            {\varphi(a,x)}%
            {\IBox{(
              \IAnd%
              {\ITotal{\IAp{e}{a}}}%
              {\psi(\IAp{e}{a}, f(x))}
            )}}
        }
      }
    }
  \]
\end{remk}

Though we will sometimes use this internal definition, other times it will be
easier to use abstract properties of triposes, for example in showing that
assemblies form a category.

\begin{cons}
  The \definiendum{category of assemblies}, denoted \(\AsmCat\), has as objects
  the assemblies and as morphisms the morphisms of assemblies.
  %
  Identity morphisms and composition are both inherited from \(\E\).
\end{cons}
\begin{proof}
  We claimed that identity morphisms and composition are inherited from \(\E\).
  %
  For the former, given an assembly \((X,\varphi)\) we have the identity
  \(\IId{X}\) which is tracked since \(\TPull{\IId{X}}\) is the identity and
  \(\leq\) is reflexive.
  %
  For composition, suppose we have morphisms of assemblies
  \(f : (Y,\psi) \to (X,\varphi)\) and \(g : (Z,\chi)\to(Y,\psi)\).
  %
  Both of these are tracked hence so \(\psi \leq \TPull{f}\varphi\) and
  \(\chi \leq \TPull{g}\psi\), but \(\TPull{g}\) is monotonic so in addition we
  also have
  \(\chi \leq \TPull{g}\psi \leq \TPull{g}\TPull{f}\varphi=\TPull{(fg)}\varphi\)
  which means that \(fg\) is tracked as necessary.
  %
  The unit and associativity equalities then follow immediately as \(\E\) is a
  category.
\end{proof}

\begin{lemm}\label{lemm:assemblies-finite-limits}
  The category of assemblies \(\AsmCat\) has all finite limits.
\end{lemm}
\begin{proof}
  We construct binary products and equalisers from which all finite limits
  follow.

  Fix two assemblies \((X,\varphi)\) and \((Y,\psi)\), the underlying object of
  their product will be the product \(\IProd{X}{Y}\) and the realizability
  relation will be given by
  \(\TAnd{(\TPull{\IFst}\varphi)}{(\TPull{\ISnd}\psi)}{\IProd{X}{Y}}\).
  %
  This is total by lemmas~\ref{lemm:pullback-preserves-total}
  and~\ref{lemm:meet-total}.
  %
  The projections \(\IFst\) and \(\ISnd\) are tracked as we have
  \(\TAnd{(\TPull{\IFst}\varphi)}{(\TPull{\ISnd}\psi)}{\IProd{X}{Y}} \leq \TPull{\IFst}\varphi\)
  and
  \(\TAnd{(\TPull{\IFst}\varphi)}{(\TPull{\ISnd}\psi)}{\IProd{X}{Y}} \leq \TPull{\ISnd}\psi\).
  %
  This leaves us to show that given morphisms \(f : (Z,\chi) \to (X,\varphi)\)
  and \(g : (Z,\chi) \to (Y,\psi)\) that \(\IPair{f}{g} : Z \to \IProd{X}{Y}\)
  is tracked.
  %
  Since \(f\) and \(g\) are tracked we know that
  \[
    \chi \leq \TAnd{(\TPull{f}\varphi)}{(\TPull{g}\psi)}{Z}
         = \TAnd{\TPull{(\IFst\IPair{f}{g})}\varphi}{\TPull{(\ISnd\IPair{f}{g})}\psi}{Z}
         = \TPull{\IPair{f}{g}}\left[\TAnd{(\TPull{\IFst}\varphi)}{(\TPull{\ISnd}\psi)}{\IProd{X}{Y}}\right]
  \]
  which shows that \(\IPair{f}{g}\) is tracked and so the category of assemblies
  has binary products.

  For equalisers fix two morphisms \(f,g : (X,\varphi) \to (Y,\psi)\) and
  denote their equaliser in \(\E\) by \(m : \IEqualiser{f}{g} \to X\).
  %
  We turn this equaliser into an assembly by giving it the realizability
  predicate \(\TPull{m}\varphi\), the totality of which follows from lemma
  \ref{lemm:pullback-preserves-total}.
  %
  To show \(m\) is tracked amounts to proving
  \(\TPull{m}\varphi \leq \TPull{m}\varphi\), which holds by reflexivity of
  \(\leq\).
  %
  Finally suppose we have \(h : (Z,\chi) \to (X,\varphi)\) which equalises \(f\)
  and \(g\), then the universal property of \(\IEqualiser{f}{g}\) tells us there
  exists a unique map \(u : Z \to \IEqualiser{f}{g}\) such that \(h = mu\).
  %
  As \(h\) is tracked, then so is \(u\) which follows from
  \(\chi\leq\TPull{h}\varphi=\TPull{(mu)}\varphi=\TPull{u}(\TPull{m}\varphi)\).
\end{proof}

\begin{lemm}\label{lemm:assemblies-cartesian-closed}
  The category of assemblies \(\AsmCat\) is cartesian closed.
\end{lemm}
\begin{proof}
  From \Cref{lemm:assemblies-finite-limits} we know that binary products exist,
  it thus remains to show that exponentials exist.
  %

\end{proof}

\subsection{Realizability Topos}%
\label{sub:realizability-topos}

The definition of the realizability topos follows by simply
unfolding the tripos-to-topos construction so we don't focus on it for now.
%
Eventually it would be good to look at assemblies as a full subcategory of the
realizability topos given by the subobjects of the constant objects, and
compare these to the more elementary, direct definition of assemblies.

\subsection{Sheafififcation}

\todo[inline]{Recall sheafification as a reflective subcategory. Maybe cite
  McLarty Chapter 21 for this?}

Given a Lawvere-Tierney topology \(\IBoxSym : \IProp \to \IProp\) in \(\E\), we
can always define a reflective subcategory \(\Ej\) of sheaves.
%
That is, we have a reflection functor \(\ISheafSym : \E \to \Ej\) which is
left adjoint to the functor including \(\Ej\) in \(\E\).
%
In the case of sheafification, \(\ISheafSym\) preserves finite limits,
so we actually have a geometric embedding of \(\Ej\) in \(\E\).

\todo[inline]{Define geometric morphism between triposes}

We will now define an analogous sheafification operation on
the realizability topos \(\Adj{\E}{\Trip}\).
%
First, notice that the restriction of \(T\) to the subcategory \(\Ej\) gives an
\(\Ej\)-tripos.
%
We only need to check that the power objects in \(\E\) associated with \(T\) are
sheaves, and hence still exist in \(\Ej\), which holds as \(\Ej\) is an
exponential ideal of \(\E\).\todo{elaborate on this once description of power
objects is typed up.}

What we are after now, is a geometric embedding of \(\Adj{\Ej}{T}\) into
\(\Adj{\E}{T}\), which we expect to act on the underlying objects via
sheafification.
%
For this, it is helpful to pull results


%By change of base~\cite[Lemma 2.1.3]{oostenRealizabilityIntroductionIts2008}, we
%can reindex the \(\E\)-tripos \(T\) to get a tripos
%\(T\circ\ISheafSym^{\text{op}}\) on the category of sheaves \(\Ej\).
%%
%This situation was already considered
%in~\cite[\S3]{vanoostenExercisesRealizability2018} and Proposition 3.1
%showed that \(T\circ\ISheafSym^{\text{op}}\) is equivalent to the restriction
%of \(T\) to \(\)
%
%From Proposition 3.1 of~

\todo[inline]{Cite van Oosten to get geometric morphism between realizability
  toposes and show how definitions compute}

\todo[inline]{Show that sheafification preserves the property ``is a subobject
  of a constant object PER'', so it restricts to acting on the category of
  assemblies}

\todo[inline]{Present issue with particular instances where sheafification
of nat should be isomorphic to pure nats}

\todo[inline]{Give alternate definition which should be more versatile but
  presumably something breaks? Or is this our free lunch?}

%\subsubsection{An internal description of sheafification}
%
%Working internally, we say a type \(A\) is a sheaf if we can equip it with a
%function
%%
%\[
%  \IGlueSym{A} : (P : \IProp) \to \IBox{P} \to (P \to A) \to A
%\]
%%
%such for all elements \(a : A\), the glueing of the respective constant family
%is equal to \(a\).
%%
%That is, we have \(\IGlue{P}{q}{\lambda i.a}{A} = a\) for all propositions
%\(P\), proofs \(q : \IBox{P}\) and \(a : A\).
%
%\begin{defn}
%  We define the \definiendum{sheafification of \(X\)} as the following
%  quotient-inductive type:
%  %
%  \begin{mathpar}
%    \inferrule%
%    {a : A}%
%    {\ILeaf{a} : \ISheaf{A}}
%
%    \inferrule%
%    {P : \Omega \\ q : \IBox{P} \\ \phi : P \to \ISheaf{A}}%
%    {\IBranch{P}{q}{\phi} : \ISheaf{A}}
%
%    \inferrule%
%    {P : \Omega \\ q : \IBox{P} \\ a : \ISheaf{A}}%
%    {\IBranch{P}{q}{\lambda i. a} = a : \ISheaf{A}}
%  \end{mathpar}
%\end{defn}

%\subsubsection{Sheafification in the realizability topos}

%Usually sheaves are described as a reflective subcategory of a category
%of presheaves.
%%
%That means we have an adjoint pair of functors \(L \dashv R\) with
%\(R\) fully faithful.
%%
%The domain of \(R\) is then the category of sheaves, and its codomain the
%category of presheaves.
%%
%We view \(R\) as the inclusion of sheaves into presheaves and \(L\)
%as the sheafification of presheaves.
%%
%From the adjointness condition we recover the property that mapping out
%of the sheafification of a presheaf into a sheaf is equivalent to mapping out
%of the original presheaf into the same sheaf.
%
%For now we look for an analogous sheafification operation in the category
%of assemblies.
%%
%Presumably, the action of said operation on the underlying presheaves
%will be actual sheafification.
%%
%That leaves the action on the realizability relations up for debate.
%
%\begin{defn}\label{defn-sheafification}
%  Given an object \((X,{\approx})\) of the realizability topos \(\Topos\), we
%  define the \definiendum{sheafification of \((X,{\approx})\)} as the pair
%  \((\ISheaf{X},{\ISheafP{\approx}})\), where \(\ISheaf{X}\) denotes the
%  sheafification of \(X\) and the relation
%  \({\ISheafP{\approx}} : \ISheaf{X} \times \ISheaf{X} \times \A \to \IPropCl\) is
%  the canonical extension of \({\approx} : X \times X \times \A \to \IPropCl\)
%  described by the following sequence of isomorphisms:
%  %
%  \[
%    \arraycolsep=0.2em
%    \begin{array}{rcl}
%      X \times X \times \A &\to& \IPropCl \\\midrule\midrule
%      X \times X &\to& (\IFun{\A}{\IPropCl})\\\midrule\midrule
%      \ISheaf{(X \times X)} &\to& (\IFun{\A}{\IPropCl})\\\midrule\midrule
%      \ISheaf{X} \times \ISheaf{X} &\to& (\IFun{\A}{\IPropCl})\\\midrule\midrule
%      \ISheaf{X} \times \ISheaf{X} \times \A &\to& \IPropCl
%    \end{array}
%  \]
%  %
%  where we made use of the fact that sheaves form an exponential ideal and
%  that sheafification preserves limits.
%\end{defn}
%\begin{proof}
%  We must check that \({\ISheafP{\approx}}\) is still symmetric and
%  transitive in the internal logic of our realizability tripos.
%  %
%  For symmetry we have to check that given \(x,y : X\),
%  \(\ILeaf{x} \ISheafP{\approx} \ILeaf{y}\) implies
%  \(\ILeaf{y} \ISheafP{\approx} \ILeaf{x}\).
%  %
%  By definition of \({\ISheafP{\approx}}\), this amounts to showing that
%  \(x \approx y\) implies \(y \approx x\), which is true by assumption.
%  %
%  We must also check that given \(P, Q : \IProp\), proofs \(r : \IBox{P}\) and
%  \(s : \IBox{Q}\), and families \(\phi : \IFun{P}{\ISheaf{X}}\) and
%  \(\psi : \IFun{Q}{\ISheaf{X}}\) such that \(\phi\) and \(\psi\) are pointwise
%  related by \(\ISheafP{\approx}\), then
%  \(\IBranch{P}{r}{\phi} \ISheafP{\approx} \IBranch{Q}{s}{\psi}\) implies
%  \(\IBranch{Q}{s}{\psi} \ISheafP{\approx} \IBranch{P}{r}{\phi}\).
%  %
%  Unfolding the definition of \({\ISheafP{\approx}}\) on branches, we see it
%  suffices to show that for all proofs \(p : P\) and \(q : Q\) we have
%  \(\phi(p) \ISheafP{\approx} \psi(q)\) then
%  \(\psi(q) \ISheafP{\approx} \phi(p)\), which is true by the inductive
%  hypothesis.
%  %
%  We must also show this new relation is transitive, which is proved
%  by a similar induction.
%\end{proof}

\newpage

\section{Presheaf pcas for choice sequences}

\begin{defn}\label{defn-choice-sequence-pca-gadget}
  A \definiendum{presheaf gadget} consists of a set \(\mathbb{W}\) of worlds
  partially ordered by \(\leq\), a set \(\mathsf{C}\) of codes, two
  distinguished codes \(k\ s : \mathsf{C}\), and for each world both an
  equivalence relation \({\equiv_{w}}\) on \(\mathsf{C}\) and a partial function
  \(- \cdot_{w} - : \mathsf{C} \times \mathsf{C} \rightharpoonup \mathsf{C}\),
  subject to the following conditions:
  \begin{gather}
    w \leq v \implies (a \equiv_{w}b  \implies a \equiv_{v} b) \land \IPLeq{a \cdot_{w} b}{a \cdot_{v} b}\\
    a \equiv_{w} a' \land b \equiv_{w} b' \land \ITotal{a \cdot_{w} b}
        \implies a \cdot_{w}  \\
    k \cdot_{w} a = k \cdot_{v} a \qquad
    k \cdot_{w} a \cdot_{w} b = a \\
    s \cdot_{w} a = s \cdot_{v} a \qquad
    s \cdot_{w} a \cdot_{w} b = s \cdot_{v} a \cdot_{v} b \qquad
    \IPLeq{a \cdot_{w} c \cdot_{w} (b \cdot_{w} c)}{s \cdot_{w} a \cdot_{w} b \cdot_{w} c}
  \end{gather}
\end{defn}

%\begin{defn}\label{defn-choice-sequence-pca-gadget}
%  A \definiendum{presheaf gadget} consists of the following
%  data:
%  \begin{itemize}
%    \item A set \(\mathbb{W}\) of worlds partially ordered by \(\leq\);
%    \item A set \(\mathsf{C}\) of codes;
%    \item For each world \(w\), an equivalence relation
%      \({\equiv_{w}} \subseteq \mathsf{C} \times \mathsf{C}\), such that
%      \(w \leq v\) implies \({\equiv_{v}} \subseteq {\equiv_{w}}\);
%    \item For each world \(w\), a partial function
%      \(- \cdot_{w} - : \mathsf{C} \times \mathsf{C} \rightharpoonup \mathsf{C}\)
%      which is a congruence for \(\equiv_{w}\) and such that \(w \leq v\)
%      implies \(\IPLeq{a \cdot_{v} b}{a \cdot_{w} b}\);
%    \item A code \(k : C\) such that for all codes \(a\ b:C\) and worlds
%      \(w \leq v\) we have
%      %
%      \[
%        k \cdot_{w} a = k \cdot_{v} a
%        \qquad
%        k \cdot_{w} a \cdot_{w} b = a
%      \]
%    \item A code \(s : C\) such that for all codes \(a\ b\ c : C\) and worlds
%      \(w \leq v\) we have
%      %
%      \[
%        s \cdot_{w} a = s \cdot_{v} a
%        \qquad
%        s \cdot_{w} a \cdot_{w} b = s \cdot_{v} a \cdot_{v} b
%        \qquad
%        \IPLeq{a \cdot_{w} c \cdot_{w} (b \cdot_{w} c)}{s \cdot_{w} a \cdot_{w} b \cdot_{w} c}
%      \]
%  \end{itemize}
%\end{defn}

From a presheaf gadget we can easily define a pca object in
the category of presheaves on~\(\mathbb{W}^{\text{op}}\) and all of the examples
we are interested in will be of this form.
%
In the data for a presheaf gadget we ask for an indexed system of equivalence
relations \(\equiv_{w}\), which play the role of conversion relations: as we
move to later worlds, terms that once were neutrals due to choice sequences
may become normalisable, at which point we may wish to equate them.
%
The only pca objects we will not be able to talk about via gadgets
are those in which new codes appear at later worlds.
%
For example in world \(v\) which extends \(w\) we could have access to a code
\(e\) which did not exist in \(w\).
%
This seems like a strange instance and it is not entirely clear what
practical purposes it would allow, perhaps it could be interesting
to have worlds with only ``computable'' codes and later worlds
with ``uncomputable'' codes, \`a la relative realizability, but we
leave such explorations alone for now.

\begin{cons}
  To each presheaf gadget we associate a pca object \(\A\) in the
  category~\(\widehat{\mathbb{W}^{\text{op}}}\) whose underlying presheaf
  is given by the quotient \({\mathsf{C}}/{\equiv_{w}}\) for each world \(w\)
  and whose transition maps are the relevant quotient maps.
  %
  Similarly, the application map \(\A \times \A \rightharpoonup \A\) is given
  for each world \(w\) by the extension of \(\cdot_{w}\) to
  \({\mathsf{C}}/{\equiv_{w}}\), and the combinators \(k\) and \(s\) are given
  by our distinguished codes.
\end{cons}

\begin{defn}
  A \definiendum{presheaf gadget with choice sequences} is a
  presheaf gadget along with the further data:
  \begin{itemize}
    \item A Grothendieck topology \(C\) on \(\mathbb{W}^{\text{op}}\);
    \item A distinguished subset \(\textsf{CS} \subseteq \textsf{C}\) of choice
      sequences;
    \item A function
      \(\textsf{eval} : \textsf{CS} \to \mathbb{W} \to \mathbb{N} \rightharpoonup \mathbb{N}\)
      such that for all \(\delta : \textsf{CS}\), \(n : \mathbb{N}\) and
      \(w : \mathbb{W}\), we have that the equivalence
      \(\IPSim{\delta \cdot_{w} \overline{n}}{\overline{\textsf{eval}(\delta,w,n)}}\)
      of partial elements of \(\textsf{C}\);
    \item A function
      \(\textsf{dom} : \textsf{CS} \to (w : \mathbb{W}) \to C(w)\) such that for
      all \(\delta : \textsf{CS}\), \(n : \mathbb{N}\) and \(w : \mathbb{W}\),
      the a priori partial function
      \(\textsf{eval}(\delta,-,n) : \mathbb{W} \rightharpoonup \mathbb{N}\) is
      total on \(\textsf{dom}(\delta,w)\subseteq \mathbb{W}\).
  \end{itemize}
\end{defn}

\newpage
\appendix

\section{Some intuitions from Set-based realizability}

Let us focus on standard set-based realizability for now, where the connection
between assemblies and the realizability topos is well-understood.
%
Given a set-based tripos \(P\), its realizability topos is given by the
following:

\begin{defn}\label{defn-appendix-realizability-topos}
  The \definiendum{objects of the realizability topos} consist of a set \(X\)
  along with a binary relation \({\approx} : P(\IProd{X}{X})\) which is
  \[\begin{array}{ll}
    \textbf{(symmetric)}& x:X,\,y:X \mid x \approx y \vdash y \approx x\\
    \textbf{(transitive)}& x:X,\,y:X,\,z:X \mid x \approx y,\,y \approx z \vdash x \approx z
  \end{array}\]
  %
  The \definiendum{morphisms of the realizability topos}
  from \((X,{ \approx_{X} })\) to \((Y,{ \approx_{Y} })\) consist of
  equivalence classes of binary relations \(F : P(\IProd{X}{Y})\) which are
  \[\begin{array}{ll}
      \textbf{(strict)}& x:X,\,y:Y \mid
                         F(x,y) \vdash
                         x\approx_{X}x \land y\approx_{Y}y\\
      \textbf{(total)}& x:X, \mid
                         x\approx_{X}x \vdash
                         \exists y:Y, F(x,y)\\
      \textbf{(extensional)}&
                              x:X,\,x':X,\,y:Y,\,y':Y \mid
                              x\approx_{X}x',\,F(x,y)\,F(x',y') \vdash
                              y\approx_{Y}y'
  \end{array}\]
  where two such relations \(F,G\) are in the same equivalence class if
  \(x:X,\,y:Y\mid F(x,y) \dashv\vdash G(x,y)\).
\end{defn}

So although morphisms are given by relations, the extra conditions imposed on
them mean they behave a lot more like functions than maybe is apparent at first.
%
More specifically, given an object \(X,\approx_{X}\), we should think of it as
the set \(\{x : X \mid x\approx_{X}x\}\) quotiented by \(\approx_{X}\).
%
Under this view, a morphism from \((X,\approx_X)\) to \((Y,\approx_Y)\)
does give an actual function.
%
Of course, this is mainly an intuition: the objects and morphisms actually
contain some ``computability'' information from the tripos \(P\) which is lost
this way.

%\todo[inline]{following paragraph is wrong, can I fix it?}
%Expanding on this previous point, let us now consider the effective topos, that
%is the realizability topos associated with Kleene's first algebra
%\(\mathcal{K}_{1}\).
%%
%In the effective topos we have the
%objects \((\mathbb{N}, \sim)\) and \((\mathbb{N}, \approx)\),
%both with underlying sets the natural numbers and the following
%relations:
%%
%\[
%  \begin{array}{cc}
%    n \sim m \IsDefined
%      \begin{cases}
%        \{n\} & \text{ if } n = m \\
%        \emptyset & \text{ otherwise }
%      \end{cases}
%    &\qquad\qquad n \approx m \IsDefined \{0\}
%  \end{array}
%\]
%%
%The first of these objects is quite canonical and in fact turns out to be the
%natural number object in the effective topos.
%%
%The latter is a little less canonical
%be just enough to get some weird results.
%%
%Regardless, they are both symmetric and transitive: in the case of \(\sim\)
%these are both realized by the identity function and in the case of \(\approx\)
%they are both realized by the constantly zero function.
%%
%We have the following two relations \(F\) and \(G\) that represent morphisms
%from \((\mathbb{N},\sim)\) to \((\mathbb{N},\approx)\):
%%
%\[
%  \begin{array}{cc}
%    F(n, m) \IsDefined
%      \begin{cases}
%        \{n\} & \text{ if } n = m \\
%        \emptyset & \text{ otherwise }
%      \end{cases}
%    &\qquad\qquad G(n, m) \IsDefined
%      \begin{cases}
%        \{0\} & \text{ if } n = m \\
%        \emptyset & \text{ otherwise }
%      \end{cases}
%  \end{array}
%\]
%%
%These relations are indeed both strict, total and extensional.
%%
%In proving strictness of \(F\) we require

\printbibliography{}

\end{document}
